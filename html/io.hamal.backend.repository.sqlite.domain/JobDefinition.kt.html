<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JobDefinition.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bootstrap</a> &gt; <a href="index.source.html" class="el_package">io.hamal.backend.repository.sqlite.domain</a> &gt; <span class="el_source">JobDefinition.kt</span></div><h1>JobDefinition.kt</h1><pre class="source lang-java linenums">package io.hamal.backend.repository.sqlite.domain

import io.hamal.backend.repository.api.FuncCmdRepository
import io.hamal.backend.repository.api.FuncCmdRepository.Command
import io.hamal.backend.repository.api.FuncCmdRepository.Command.FuncToCreate
import io.hamal.backend.repository.api.domain.Func
import io.hamal.backend.repository.sqlite.BaseRepository
import io.hamal.backend.repository.sqlite.internal.Connection
import io.hamal.lib.domain.ComputeId
import io.hamal.lib.common.Shard
import io.hamal.lib.domain.vo.Code
import io.hamal.lib.domain.vo.FuncId
import io.hamal.lib.domain.vo.FuncName
import java.nio.file.Path
import kotlin.io.path.Path


<span class="nc" id="L18">class SqliteFuncRepository(config: Config) : BaseRepository(config), FuncCmdRepository {</span>

//    internal val lock: Lock
//    internal val connection: Connection
//    internal val template: NamedParameterJdbcTemplate


<span class="nc" id="L25">    data class Config(</span>
<span class="nc" id="L26">        override val path: Path,</span>
<span class="nc" id="L27">        override val shard: Shard</span>
    ) : BaseRepository.Config {
<span class="nc" id="L29">        override val filename = &quot;funcs&quot;</span>
    }

//    companion object {
//        fun open(segment: Config): DefaultJobDefinitionStore {
//            val dbPath = ensureDirectoryExists(segment)
//
//            val dataSource = DriverManagerDataSource()
//            dataSource.setDriverClassName(&quot;org.sqlite.JDBC&quot;)
//            dataSource.setUrl(&quot;jdbc:sqlite:$dbPath.db&quot;)
//
//            val template = NamedParameterJdbcTemplate(dataSource)
//
//            val result = DefaultJobDefinitionStore(
//                lock = ReentrantLock(),
////                connection = DriverManager.getConnection(&quot;jdbc:sqlite:$dbPath.db&quot;),
//                connection = template.jdbcTemplate.dataSource.connection,
//                template = template
//            )
//
//            result.setupSqlite()
//            result.setupSchema()
//
//            return result
//        }
//
//        private fun ensureDirectoryExists(config: Config): Path {
//            return Files.createDirectories(config.path)
//                .resolve(Path(String.format(&quot;job-definitions-%04d&quot;, config.shard.value.toLong())))
//        }
//    }

    override fun get(id: FuncId): Func {
<span class="nc bnc" id="L62" title="All 2 branches missed.">        return connection.executeQueryOne(&quot;SELECT id, version, request_id, reference FROM funcs WHERE id = :id&quot;) {</span>
<span class="nc" id="L63">            with { set(&quot;id&quot;, id) }</span>
<span class="nc" id="L64">            map {</span>
<span class="nc" id="L65">                Func(</span>
<span class="nc" id="L66">                    id = it.getDomainId(&quot;id&quot;, ::FuncId),</span>
<span class="nc" id="L67">                    name = FuncName(it.getString(&quot;reference&quot;)),</span>
<span class="nc" id="L68">                    code = Code(&quot;&quot;)</span>
                )
            }
<span class="nc" id="L71">        } ?: throw IllegalArgumentException(&quot;No job definition found for $id&quot;)</span>
    }


    override fun execute(computeId: ComputeId, commands: List&lt;Command&gt;): List&lt;Func&gt; {

<span class="nc" id="L77">        val toProcess = commands.groupBy { it.funcId }</span>

        //            template.update(
//                &quot;INSERT INTO request_log(id, instant) VALUES (:id, unixepoch())&quot;,
//                mapOf(&quot;id&quot; to BigDecimal(&quot;123&quot;))
//            )

//        this.apply { }

//        inTx { operations -&gt;
//            operations.execute(&quot;INSERT INTO request_log(id, instant) VALUES (:id, unixepoch())&quot;) {
//                set(&quot;id&quot;, requestId)
//            }
//            operations.abort()
//        }


//        inTx {
////            execute(&quot;INSERT INTO request_log(id, instant) VALUES (:id, unixepoch())&quot;) {
////                set(&quot;id&quot;, requestId)
////            }
//        }

//        val operations = Operations()
//        operations.execute(&quot;&quot;&quot;select *&quot;&quot;&quot;) {
//            set(&quot;popo&quot;, &quot;smells&quot;)
//        }
//
//        operations.execute(&quot;PRAGMA journal_mode = exclusive;&quot;)

//    template.execute(&quot;PRAGMA temp_store = memory&quot;) {}

//
//        try {
//            connection.autoCommit = false
//            connection.beginRequest()
//
//            toProcess.forEach { (id, commands) -&gt;
//                commands.sortedBy { it.order }.forEach { command -&gt;
//                    when (command) {
//                        is JobDefinitionToInsert -&gt; insertJobDefinition(requestId, command)
//                        else -&gt; TODO(&quot;Command not supported yet $command&quot;)
//                    }
//                }
//                updateVersion(id)
//            }
//
//            connection.commit()
//        } catch (t: Throwable) {
//            connection.rollback()
//            throw t
//        } finally {
//            connection.endRequest()
//            connection.autoCommit = true
//        }
//
<span class="nc" id="L133">        return listOf(</span>
<span class="nc" id="L134">            Func(</span>
<span class="nc" id="L135">                id = toProcess.keys.first(),</span>
<span class="nc" id="L136">                name = FuncName(&quot;das&quot;),</span>
<span class="nc" id="L137">                Code(&quot;&quot;)</span>
            )
        )
    }

//    override fun setupConnection(operations: NamedParameterJdbcOperations) {
//    override fun setupConnection(connection: Connection) {
////        NamedParameters {
////            set(&quot;abc&quot;, 123)
////        }
////        TODO(&quot;Not yet implemented&quot;)
//    }
//
////    override fun setupSchema(operations: NamedParameterJdbcOperations) {
//    override fun setupSchema(connection: Connection) {
////        inTx {
////            execute(
////                &quot;&quot;&quot;
////            CREATE TABLE IF NOT EXISTS request_log (
////                id          BIGINT PRIMARY KEY,
////                instant     DATETIME NOT NULL
////            );
////            &quot;&quot;&quot;.trimIndent()
////            )
////
////            execute(
////                &quot;&quot;&quot;
////            CREATE TABLE IF NOT EXISTS funcs (
////                id          INTEGER PRIMARY KEY,
////                version     INTEGER NOT NULL ,
////                reference   TEXT NOT NULL ,
////                inputs      BLOB,
////                secrets     BLOB,
////                instant     DATETIME NOT NULL
////            );
////            &quot;&quot;&quot;.trimIndent()
////            )
////
////            execute(
////                &quot;&quot;&quot;
////           CREATE TABLE IF NOT EXISTS triggers(
////                id INTEGER PRIMARY KEY,
////                func_id INTEGER NOT NULL,
////                type INTEGER NOT NULL,
////                inputs BLOB,
////                secrets BLOB,
////                data BLOB
////            );
////            &quot;&quot;&quot;.trimIndent()
////            )
////        }
//    }

//    override fun drop() {
////        inTx {
////            execute(&quot;&quot;&quot;DROP TABLE IF EXISTS funcs;&quot;&quot;&quot;)
////            execute(&quot;&quot;&quot;DROP TABLE IF EXISTS triggers;&quot;&quot;&quot;)
////            execute(&quot;&quot;&quot;DROP TABLE IF EXISTS request_log;&quot;&quot;&quot;)
////        }
//    }

//    override fun setupConnection() {
//        connection.execute(&quot;&quot;&quot;PRAGMA journal_mode = wal;&quot;&quot;&quot;)
//        connection.execute(&quot;&quot;&quot;PRAGMA locking_mode = exclusive;&quot;&quot;&quot;)
//        connection.execute(&quot;&quot;&quot;PRAGMA temp_store = memory;&quot;&quot;&quot;)
//        connection.execute(&quot;&quot;&quot;PRAGMA synchronous = off;&quot;&quot;&quot;)
//    }
//
//    override fun setupSchema() {
//
//        connection.execute(&quot;&quot;&quot;DROP TABLE IF EXISTS funcs;&quot;&quot;&quot;)
//        connection.execute(&quot;&quot;&quot;DROP TABLE IF EXISTS triggers;&quot;&quot;&quot;)
//        connection.execute(
//            &quot;&quot;&quot;
//            CREATE TABLE IF NOT EXISTS funcs (
//                id          INTEGER PRIMARY KEY,
//                version     INTEGER NOT NULL ,
//                request_id  BIGINT  NOT NULL,
//                reference   TEXT NOT NULL ,
//                inputs      BLOB,
//                secrets     BLOB,
//                instant     DATETIME NOT NULL,
//                UNIQUE (request_id)
//            );
//        &quot;&quot;&quot;.trimIndent()
//        )
//
//        connection.execute(
//            &quot;&quot;&quot;
//           CREATE TABLE IF NOT EXISTS triggers(
//                id INTEGER PRIMARY KEY,
//                func_id INTEGER NOT NULL,
//                type INTEGER NOT NULL,
//                inputs BLOB,
//                secrets BLOB,
//                data BLOB
//            );&quot;&quot;&quot;.trimIndent()
//        )
//    }

    override fun setupConnection(connection: Connection) {
<span class="nc" id="L238">        TODO(&quot;Not yet implemented&quot;)</span>
    }

    override fun setupSchema(connection: Connection) {
<span class="nc" id="L242">        TODO(&quot;Not yet implemented&quot;)</span>
    }

    override fun clear() {
<span class="nc" id="L246">        TODO(&quot;Not yet implemented&quot;)</span>
    }

}

internal fun SqliteFuncRepository.insertFunc(computeId: ComputeId, toInsert: FuncToCreate) {
//    return connection.prepareStatement(
//        &quot;&quot;&quot;INSERT INTO funcs(id, version, request_id,reference, instant) VALUES(?,?,?,?,?)&quot;&quot;&quot;,
//    ).use {
//        it.setLong(1, toInsert.jobDefinitionId.value.value)
//        it.setInt(2, 0)
//        it.setBigDecimal(3, requestId.value.toBigDecimal())
//        it.setString(4, toInsert.reference.value.value)
//        it.setTimestamp(5, Timestamp.from(TimeUtils.now()))
//        it.execute()
//    }
<span class="nc" id="L262">}</span>

internal fun SqliteFuncRepository.updateVersion(id: FuncId) {
//    return connection.prepareStatement(
//        &quot;&quot;&quot;UPDATE funcs SET version = version + 1 WHERE id = ?&quot;&quot;&quot;,
//    ).use {
//        it.setLong(1, id.value.value)
//        it.execute()
//    }
<span class="nc" id="L271">}</span>

fun main() {
<span class="nc" id="L274">    val store = SqliteFuncRepository(</span>
<span class="nc" id="L275">        SqliteFuncRepository.Config(</span>
<span class="nc" id="L276">            path = Path(&quot;/tmp/db0815&quot;),</span>
<span class="nc" id="L277">            shard = Shard(0)</span>
        )
    )


//    val dataSource = DriverManagerDataSource()
//    dataSource.setDriverClassName(&quot;org.sqlite.JDBC&quot;)
//    dataSource.setUrl(&quot;jdbc:sqlite:/tmp/test.sqlite&quot;)
//
//    val transactionManager = DataSourceTransactionManager(dataSource);
//    val transactionTemplate = TransactionTemplate(transactionManager);
//    transactionTemplate.propagationBehavior = TransactionDefinition.PROPAGATION_REQUIRES_NEW;
//
//    val template = NamedParameterJdbcTemplate(dataSource)
//
//
//    val id = JobDefinitionId(SnowflakeId(2199023255552))
//
////    transactionTemplate.execute {
//    template.execute(&quot;PRAGMA journal_mode = wal;&quot;) {}
//    template.execute(&quot;PRAGMA journal_mode = exclusive;&quot;) {}
//    template.execute(&quot;PRAGMA temp_store = memory&quot;) {}
//    template.execute(&quot;PRAGMA synchronous = off&quot;) {}
////    }
//
//    transactionTemplate.execute {
//
//        template.jdbcTemplate.execute(&quot;&quot;&quot;DROP TABLE IF EXISTS funcs;&quot;&quot;&quot;)
//        template.jdbcTemplate.execute(&quot;&quot;&quot;DROP TABLE IF EXISTS triggers;&quot;&quot;&quot;)
//        template.update(&quot;&quot;&quot;DROP TABLE IF EXISTS request_log;&quot;&quot;&quot;, mapOf&lt;String, Any&gt;())
//        template.update(
//            &quot;&quot;&quot;
//            CREATE TABLE IF NOT EXISTS request_log (
//                id          BIGINT PRIMARY KEY,
//                instant     DATETIME NOT NULL
//            );
//        &quot;&quot;&quot;.trimIndent(), mapOf&lt;String, Any&gt;()
//        )
//        template.jdbcTemplate.execute(
//            &quot;&quot;&quot;
//            CREATE TABLE IF NOT EXISTS funcs (
//                id          INTEGER PRIMARY KEY,
//                version     INTEGER NOT NULL ,
//                reference   TEXT NOT NULL ,
//                inputs      BLOB,
//                secrets     BLOB,
//                instant     DATETIME NOT NULL
//            );
//        &quot;&quot;&quot;.trimIndent()
//        )
//        template.jdbcTemplate.execute(
//            &quot;&quot;&quot;
//           CREATE TABLE IF NOT EXISTS triggers(
//                id INTEGER PRIMARY KEY,
//                func_id INTEGER NOT NULL,
//                type INTEGER NOT NULL,
//                inputs BLOB,
//                secrets BLOB,
//                data BLOB
//            );&quot;&quot;&quot;.trimIndent()
//        )
//    }
//
//
//    try {
//        val r = transactionTemplate.execute {
//
//            template.update(
//                &quot;INSERT INTO request_log(id, instant) VALUES (:id, unixepoch())&quot;,
//                mapOf(&quot;id&quot; to BigDecimal(&quot;123&quot;))
//            )
//
//            template.query(
//                &quot;&quot;&quot;INSERT INTO funcs(id, version, reference, instant)
//                    |    VALUES (:id,:version,:reference,:instant)
//                    |    RETURNING *&quot;&quot;&quot;.trimMargin(),
//                mapOf(
//                    &quot;id&quot; to id.value.value,
//                    &quot;version&quot; to 0,
//                    &quot;reference&quot; to &quot;abc&quot;,
//                    &quot;instant&quot; to Timestamp.from(Instant.now())
//                )
//            ) {
//                println(it.getLong(&quot;id&quot;))
//                println(it.getString(&quot;reference&quot;))
//            }
//
//
//            template.query(
//                &quot;&quot;&quot;SELECT id, version, reference FROM funcs WHERE id = :id&quot;&quot;&quot;,
//                mapOf(&quot;id&quot; to id.value.value)
//            ) { resultSet, idx -&gt;
//                println(resultSet.fetchSize)
//                JobDefinition(
//                    id = JobDefinitionId(SnowflakeId(resultSet.getLong(&quot;id&quot;))),
//                    reference = JobReference(resultSet.getString(&quot;reference&quot;)),
//                    triggers = listOf()
//                )
//            }
//        }
//        println(r)
//
//    } catch (t: Throwable) {
//        // thre request was already handled - get job definition and proceed with processing
//        if (t.localizedMessage.contains(&quot;UNIQUE constraint failed: request_log.id&quot;)) {
//            return
//        }
//        println(t.localizedMessage)
//    }
<span class="nc" id="L386">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>