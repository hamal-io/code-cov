<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Snowflake.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hamal-mono</a> &gt; <a href="index.source.html" class="el_package">io.hamal.lib.common</a> &gt; <span class="el_source">Snowflake.kt</span></div><h1>Snowflake.kt</h1><pre class="source lang-java linenums">package io.hamal.lib.common

import io.hamal.lib.common.SnowflakeId.ElapsedSource.Elapsed
import io.hamal.lib.common.SnowflakeId.SequenceSource
import io.hamal.lib.common.SnowflakeId.SequenceSource.*
import io.hamal.lib.common.util.BitUtils
import io.hamal.lib.common.Tuple2
import io.hamal.lib.common.domain.DomainId
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import java.util.concurrent.locks.Lock
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock
import kotlin.time.Duration.Companion.milliseconds


<span class="nc" id="L22">@JvmInline</span>
@Serializable(with = SnowflakeId.Serializer::class)
<span class="nc" id="L24">value class SnowflakeId(val value: Long) : Comparable&lt;SnowflakeId&gt; {</span>

<span class="fc" id="L26">    constructor(value: String) : this(value.toLong(16))</span>

    interface ElapsedSource {
        fun elapsed(): Elapsed

        @JvmInline
<span class="nc" id="L32">        value class Elapsed(val value: Long) : Comparable&lt;Elapsed&gt; {</span>
<span class="pc" id="L33">            override fun compareTo(other: Elapsed) = value.compareTo(other.value)</span>
        }
    }

    interface PartitionSource {
        fun get(): Partition
    }

    interface SequenceSource {
        /**
         * Blocks if sequence is exhausted until next milliseconds
         */
        fun next(elapsedSource: () -&gt; Elapsed): Pair&lt;Elapsed, Sequence&gt;

        @JvmInline
<span class="nc" id="L48">        value class Sequence(val value: Short) {</span>
<span class="fc" id="L49">            constructor(value: Int) : this(value.toShort())</span>

            init {
<span class="pc bpc" id="L52" title="2 of 4 branches missed.">                require(value &gt;= 0) { &quot;Sequence must not be negative - [0, 4095]&quot; }</span>
<span class="pc bpc" id="L53" title="2 of 4 branches missed.">                require(value &lt;= 4095) { &quot;Sequence is limited to 12 bits - [0, 4095]&quot; }</span>
            }
        }
    }

    interface Generator {
        fun next(): SnowflakeId
    }

<span class="fc" id="L62">    override fun compareTo(other: SnowflakeId) = value.compareTo(other.value)</span>

<span class="nc" id="L64">    fun partition(): Partition = Partition(</span>
<span class="nc" id="L65">        BitUtils.extractRange(</span>
<span class="nc" id="L66">            value = value,</span>
<span class="nc" id="L67">            startIndex = 0,</span>
<span class="nc" id="L68">            numberOfBits = 10</span>
<span class="nc" id="L69">        ).toInt()</span>
<span class="nc" id="L70">    )</span>

<span class="nc" id="L72">    fun sequence(): Sequence = Sequence(</span>
<span class="nc" id="L73">        BitUtils.extractRange(</span>
<span class="nc" id="L74">            value = value,</span>
<span class="nc" id="L75">            startIndex = 10,</span>
<span class="nc" id="L76">            numberOfBits = 12</span>
<span class="nc" id="L77">        ).toShort()</span>
<span class="nc" id="L78">    )</span>


<span class="nc" id="L81">    fun elapsed(): Elapsed = Elapsed(</span>
<span class="nc" id="L82">        BitUtils.extractRange(</span>
<span class="nc" id="L83">            value = value,</span>
<span class="nc" id="L84">            startIndex = 22,</span>
<span class="nc" id="L85">            numberOfBits = 41</span>
        )
<span class="nc" id="L87">    )</span>

<span class="nc" id="L89">    override fun toString(): String {</span>
<span class="nc" id="L90">        return &quot;$value&quot;</span>
<span class="nc" id="L91">    }</span>

    object Serializer : KSerializer&lt;SnowflakeId&gt; {
        override val descriptor: SerialDescriptor
<span class="fc" id="L95">            get() = PrimitiveSerialDescriptor(&quot;SnowflakeId&quot;, PrimitiveKind.STRING)</span>

<span class="fc" id="L97">        override fun deserialize(decoder: Decoder) = SnowflakeId(decoder.decodeString().toLong(16))</span>

        override fun serialize(encoder: Encoder, value: SnowflakeId) {
<span class="fc" id="L100">            encoder.encodeString(value.value.toString(16))</span>
<span class="fc" id="L101">        }</span>
    }
}

<span class="fc" id="L105">@OptIn(kotlin.time.ExperimentalTime::class)</span>
<span class="fc" id="L106">class DefaultElapsedSource(</span>
<span class="pc" id="L107">    val epoch: Long = 1682116276624 // 2023-04-22 some when in the morning AEST</span>
) : SnowflakeId.ElapsedSource {
<span class="fc" id="L109">    override fun elapsed() = Elapsed(source.elapsedNow().plus(epoch.milliseconds).inWholeMilliseconds)</span>

<span class="fc" id="L111">    private val source = kotlin.time.TimeSource.Monotonic.markNow()</span>
<span class="fc" id="L112">}</span>

<span class="fc" id="L114">class DefaultPartitionSource(</span>
<span class="fc" id="L115">    private val partition: Partition</span>
) : SnowflakeId.PartitionSource {
<span class="fc" id="L117">    constructor(value: Int) : this(Partition(value))</span>

<span class="fc" id="L119">    override fun get() = partition</span>
}

<span class="fc" id="L122">class DefaultSequenceSource : SequenceSource {</span>

<span class="fc" id="L124">    private var previousCalledAt: Elapsed = Elapsed(0)</span>
    private var nextSequence = 0
<span class="fc" id="L126">    private val maxSequence = 4096</span>

    override fun next(elapsedSource: () -&gt; Elapsed): Pair&lt;Elapsed, Sequence&gt; {
<span class="fc" id="L129">        val elapsed = elapsedSource()</span>
<span class="pc bpc" id="L130" title="2 of 4 branches missed.">        check(elapsed &gt;= previousCalledAt) { &quot;Elapsed must be monotonic&quot; }</span>

<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (elapsed == previousCalledAt) {</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">            if (nextSequence &gt;= maxSequence) {</span>
<span class="nc" id="L134">                while (true) {</span>
<span class="nc" id="L135">                    val currentElapsed = elapsedSource()</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">                    if (elapsed != currentElapsed) {</span>
<span class="nc" id="L137">                        nextSequence = 0</span>
<span class="nc" id="L138">                        previousCalledAt = currentElapsed</span>
<span class="nc" id="L139">                        break</span>
                    }
                }
            } else {
<span class="fc" id="L143">                nextSequence</span>
<span class="fc" id="L144">                previousCalledAt = elapsed</span>
            }

        } else {
<span class="fc" id="L148">            previousCalledAt = elapsed</span>
<span class="fc" id="L149">            nextSequence = 0</span>
        }

<span class="fc" id="L152">        return Pair(previousCalledAt, Sequence(nextSequence++))</span>
    }
}

<span class="nc" id="L156">class FixedElapsedSource(val value: Long) : SnowflakeId.ElapsedSource {</span>
<span class="nc" id="L157">    override fun elapsed() = Elapsed(value)</span>
}

<span class="fc" id="L160">class SnowflakeGenerator(</span>
<span class="fc" id="L161">    private val partitionSource: SnowflakeId.PartitionSource,</span>
<span class="fc" id="L162">    private val elapsedSource: SnowflakeId.ElapsedSource = DefaultElapsedSource(),</span>
<span class="fc" id="L163">    private val sequenceSource: SequenceSource = DefaultSequenceSource(),</span>
<span class="fc" id="L164">    private val lock: Lock = ReentrantLock()</span>
) : SnowflakeId.Generator {

    override fun next(): SnowflakeId {
<span class="fc" id="L168">        return lock.withLock {</span>
<span class="fc" id="L169">            val partition = partitionSource.get()</span>
<span class="fc" id="L170">            val (elapsed, sequence) = sequenceSource.next(elapsedSource::elapsed)</span>
<span class="fc" id="L171">            generate(elapsed, partition, sequence)</span>
        }
    }

    private fun generate(
        elapsed: Elapsed,
        partition: Partition,
        sequence: Sequence
    ): SnowflakeId {
<span class="fc" id="L180">        val elapsedValue = elapsed.value.shl(22)</span>
<span class="fc" id="L181">        val sequenceValue = sequence.value.toLong().shl(10)</span>
<span class="fc" id="L182">        val partitionValue = partition.value.toLong()</span>
<span class="fc" id="L183">        val result = elapsedValue + sequenceValue + partitionValue</span>
<span class="fc" id="L184">        return SnowflakeId(result)</span>
    }
<span class="fc" id="L186">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>