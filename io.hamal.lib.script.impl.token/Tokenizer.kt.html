<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tokenizer.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bootstrap</a> &gt; <a href="index.source.html" class="el_package">io.hamal.lib.script.impl.token</a> &gt; <span class="el_source">Tokenizer.kt</span></div><h1>Tokenizer.kt</h1><pre class="source lang-java linenums">package io.hamal.lib.script.impl.token

import io.hamal.lib.common.util.TokenizerUtils
import io.hamal.lib.common.util.TokenizerUtils.isAlpha
import io.hamal.lib.common.util.TokenizerUtils.isDigit
import io.hamal.lib.common.util.TokenizerUtils.isQuote
import io.hamal.lib.common.util.TokenizerUtils.isUnderscore
import io.hamal.lib.common.util.TokenizerUtils.isWhitespace
import io.hamal.lib.script.impl.token.Token.Type
import io.hamal.lib.script.impl.token.Token.Type.*
import io.hamal.lib.script.impl.token.Token.Type.Number

fun tokenize(code: String): List&lt;Token&gt; {
<span class="fc" id="L14">    val tokenizer = DefaultTokenizer(code)</span>
<span class="fc" id="L15">    val result = mutableListOf&lt;Token&gt;()</span>
<span class="fc" id="L16">    while (true) {</span>
<span class="fc" id="L17">        val current = tokenizer.nextToken()</span>
<span class="fc" id="L18">        result.add(current)</span>
<span class="fc bfc" id="L19" title="All 2 branches covered.">        if (current.type == Eof) {</span>
<span class="fc" id="L20">            return result</span>
        }
    }
}

interface Tokenizer {

    fun nextToken(): Token
}

<span class="fc" id="L30">class DefaultTokenizer(</span>
<span class="fc" id="L31">    val code: String,</span>
<span class="fc" id="L32">    internal var index: Int = 0,</span>
<span class="fc" id="L33">    internal var line: Int = 1,</span>
<span class="fc" id="L34">    internal var linePosition: Int = 0,</span>
<span class="fc" id="L35">    internal val buffer: StringBuffer = StringBuffer(256)</span>
) : Tokenizer {

    override fun nextToken(): Token {
<span class="fc" id="L39">        skipWhitespace()</span>
<span class="fc" id="L40">        return when {</span>
<span class="fc bfc" id="L41" title="All 2 branches covered.">            isAtEnd() -&gt; Token(Eof, tokenLine(), tokenPosition(), &quot;EOF&quot;)</span>
<span class="fc bfc" id="L42" title="All 2 branches covered.">            isHexNumber() -&gt; nextHexNumber()</span>
<span class="fc bfc" id="L43" title="All 2 branches covered.">            isNumber() -&gt; nextNumber()</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">            isString() -&gt; nextString()</span>
            else -&gt; {
<span class="fc" id="L46">                advance()</span>
<span class="fc bfc" id="L47" title="All 4 branches covered.">                nextDelimiter()</span>
<span class="fc" id="L48">                    ?: nextOperator()</span>
<span class="fc" id="L49">                    ?: run {</span>

<span class="pc bpc" id="L51" title="1 of 10 branches missed.">                        while (!isAtEnd() &amp;&amp; peek() != '(' &amp;&amp; (isAlpha(peek()) || isDigit(peek()) || isUnderscore(</span>
<span class="fc" id="L52">                                peek()</span>
                            ))
                        ) {
<span class="fc" id="L55">                            advance()</span>
                        }
<span class="fc bfc" id="L57" title="All 2 branches covered.">                        nextLiteral()</span>
<span class="fc" id="L58">                            ?: nextIdentifierOrKeyword()</span>
                    }
            }
        }
    }
<span class="fc" id="L63">}</span>

<span class="fc bfc" id="L65" title="All 4 branches covered.">private fun DefaultTokenizer.isHexNumber() = peek() == '0' &amp;&amp; peekNext() == 'x'</span>

<span class="fc bfc" id="L67" title="All 2 branches covered.">private fun DefaultTokenizer.isNumber() = isDigit(peek()) ||</span>
<span class="pc bpc" id="L68" title="1 of 6 branches missed.">        (canPeekNext() &amp;&amp; peek() == '.' &amp;&amp; isDigit(peekNext()))</span>

<span class="fc" id="L70">private fun DefaultTokenizer.isString() = isQuote(peek())</span>

<span class="fc" id="L72">private fun DefaultTokenizer.tokenPosition() = linePosition - buffer.length + 1</span>

<span class="fc" id="L74">private fun DefaultTokenizer.tokenLine() = line</span>

<span class="fc" id="L76">private fun DefaultTokenizer.tokenValue() = buffer.toString()</span>

<span class="fc bfc" id="L78" title="All 2 branches covered.">internal fun DefaultTokenizer.isAtEnd(offset: Int = 0) = index + offset &gt;= code.length</span>

<span class="fc bfc" id="L80" title="All 2 branches covered.">internal fun DefaultTokenizer.canPeekNext(offset: Int = 1) = index &lt; code.length - offset</span>

internal fun DefaultTokenizer.peek(): Char {
<span class="fc bfc" id="L83" title="All 4 branches covered.">    check(!isAtEnd()) { &quot;Can not read after end of code&quot; }</span>
<span class="fc" id="L84">    return code[index]</span>
}

internal fun DefaultTokenizer.peekPrev(): Char {
<span class="fc bfc" id="L88" title="All 4 branches covered.">    check(index &gt; 0) { &quot;Can not read before start of code&quot; }</span>
<span class="fc bfc" id="L89" title="All 4 branches covered.">    check(index &lt; code.length) { &quot;Can not read after end of code&quot; }</span>
<span class="fc" id="L90">    return code[index - 1]</span>
}

<span class="fc" id="L93">internal fun DefaultTokenizer.peekNext(offset: Int = 1): Char {</span>
<span class="fc bfc" id="L94" title="All 4 branches covered.">    check(index + offset &lt; code.length) { &quot;Can not read after end of code&quot; }</span>
<span class="fc" id="L95">    return code[index + offset]</span>
}

internal fun DefaultTokenizer.advance(): DefaultTokenizer {
<span class="fc bfc" id="L99" title="All 4 branches covered.">    check(index + 1 &lt;= code.length) { &quot;Can not read after end of code&quot; }</span>
<span class="fc" id="L100">    linePosition++</span>
<span class="fc" id="L101">    buffer.append(code[index++])</span>
<span class="fc" id="L102">    return this</span>
}

internal fun DefaultTokenizer.advanceUntilWhitespace(): DefaultTokenizer {
<span class="pc bpc" id="L106" title="1 of 4 branches missed.">    while (!isAtEnd() &amp;&amp; !isWhitespace(peek())) {</span>
<span class="fc" id="L107">        advance()</span>
    }
<span class="fc" id="L109">    return this</span>
}

internal fun DefaultTokenizer.skipWhitespace(): DefaultTokenizer {
<span class="fc bfc" id="L113" title="All 2 branches covered.">    while (!isAtEnd()) {</span>
<span class="fc" id="L114">        when (peek()) {</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">            '-' -&gt; {</span>
<span class="fc bfc" id="L116" title="All 4 branches covered.">                if (canPeekNext() &amp;&amp; peekNext() == '-') {</span>
<span class="pc bpc" id="L117" title="1 of 4 branches missed.">                    while (peek() != '\n' &amp;&amp; !isAtEnd()) {</span>
<span class="fc" id="L118">                        advance()</span>
                    }
                } else {
<span class="fc" id="L121">                    break</span>
                }
            }

<span class="fc bfc" id="L125" title="All 2 branches covered.">            '\n' -&gt; {</span>
<span class="fc" id="L126">                line++</span>
<span class="fc" id="L127">                linePosition = 0</span>
<span class="fc" id="L128">                advance()</span>
            }

<span class="fc bfc" id="L131" title="All 10 branches covered.">            ' ', '\r', '\t' -&gt; {</span>
<span class="fc" id="L132">                advance()</span>
            }

<span class="fc" id="L135">            else -&gt; break</span>
        }
    }
<span class="fc" id="L138">    buffer.setLength(0)</span>
<span class="fc" id="L139">    return this</span>
}


internal fun DefaultTokenizer.nextNumber(): Token {
<span class="pc bpc" id="L144" title="2 of 4 branches missed.">    assert(</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        isDigit(peek()) ||</span>
<span class="pc bpc" id="L146" title="3 of 6 branches missed.">                (canPeekNext() &amp;&amp; peek() == '.' &amp;&amp; isDigit(peekNext()))</span>
    )
<span class="fc bfc" id="L148" title="All 4 branches covered.">    while (!isAtEnd() &amp;&amp; isDigit(peek())) {</span>
<span class="fc" id="L149">        advance()</span>
    }
<span class="fc bfc" id="L151" title="All 4 branches covered.">    if (!isAtEnd() &amp;&amp; peek() == '.') {</span>
<span class="fc" id="L152">        advance()</span>
<span class="fc bfc" id="L153" title="All 4 branches covered.">        while (!isAtEnd() &amp;&amp; isDigit(peek())) {</span>
<span class="fc" id="L154">            advance()</span>
        }
    }
<span class="fc" id="L157">    return Token(Number, tokenLine(), tokenPosition(), tokenValue())</span>
}

internal fun DefaultTokenizer.nextHexNumber(): Token {
<span class="pc bpc" id="L161" title="4 of 8 branches missed.">    assert(peek() == '0' &amp;&amp; peekNext() == 'x')</span>
<span class="fc" id="L162">    advance(); // 0</span>
<span class="fc" id="L163">    advance(); // x</span>
<span class="pc bpc" id="L164" title="1 of 4 branches missed.">    while (!isAtEnd() &amp;&amp; TokenizerUtils.isHexChar(peek())) {</span>
<span class="fc" id="L165">        advance();</span>
    }
<span class="fc" id="L167">    return Token(HexNumber, tokenLine(), tokenPosition(), tokenValue())</span>
}

internal fun DefaultTokenizer.nextString(): Token {
<span class="pc bpc" id="L171" title="2 of 4 branches missed.">    assert(isQuote(peek()))</span>
<span class="fc" id="L172">    advance() // remove first quote</span>
<span class="fc" id="L173">    var newLineCounter = 0</span>
<span class="fc" id="L174">    while (true) {</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (isAtEnd()) {</span>
<span class="fc" id="L176">            return Token(Error, tokenLine(), tokenPosition(), &quot;Unterminated string&quot;)</span>
        }

<span class="fc bfc" id="L179" title="All 4 branches covered.">        if (isQuote(peek()) &amp;&amp; peekPrev() != '\\') {</span>
<span class="fc" id="L180">            break</span>
        }

<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (peek() == '\n') {</span>
<span class="fc" id="L184">            newLineCounter++</span>
        }

<span class="fc" id="L187">        advance()</span>
    }
<span class="fc" id="L189">    advance() // remove last quote</span>
<span class="fc" id="L190">    return Token(Type.String, tokenLine(), tokenPosition(), buffer.substring(1, buffer.length - 1))</span>
}

internal fun DefaultTokenizer.nextIdentifierOrKeyword(): Token {
<span class="fc bfc" id="L194" title="All 2 branches covered.">    return asKeyword() ?: Token(Identifier, tokenLine(), tokenPosition(), tokenValue())</span>
}

<span class="pc bfc" id="L197" title="All 2 branches covered.">val keywordMapping = Type.values().filter { it.category == Category.Keyword }.associateBy { it.value }</span>

private fun DefaultTokenizer.asKeyword(): Token? {
<span class="fc" id="L200">    val value = buffer.toString()</span>
<span class="fc" id="L201">    return keywordMapping[value]</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        ?.let { Token(it, tokenLine(), tokenPosition(), value) }</span>
}

<span class="pc bfc" id="L205" title="All 2 branches covered.">val operatorMapping = Type.values().filter { it.category == Category.Operator }.associateBy { it.value }</span>

private fun DefaultTokenizer.nextOperator(): Token? {
<span class="fc bfc" id="L208" title="All 2 branches covered.">    return nextLookAheadOperator() ?: run {</span>
<span class="fc" id="L209">        val value = buffer.toString()</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">        return operatorMapping[value]?.let { Token(it, tokenLine(), tokenPosition(), value) }</span>
    }
}

private fun DefaultTokenizer.nextLookAheadOperator(): Token? {
<span class="fc" id="L215">    val buffer = StringBuffer(buffer)</span>

<span class="fc bfc" id="L217" title="All 2 branches covered.">    for (lookAheadIndex in 0 until 3) {</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if (!canPeekNext(lookAheadIndex)) {</span>
<span class="fc" id="L219">            break</span>
        }
<span class="fc" id="L221">        buffer.append(peekNext(lookAheadIndex))</span>
<span class="fc" id="L222">        val candidate = operatorMapping[buffer.toString()]</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (candidate != null) {</span>
<span class="fc" id="L224">            val noMoreCharacters = (</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">                    canPeekNext(lookAheadIndex + 1) &amp;&amp;</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">                            (isWhitespace(peekNext(lookAheadIndex + 1)) ||</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">                            isAlpha(peekNext(lookAheadIndex + 1)) ||</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">                            isDigit(peekNext(lookAheadIndex + 1))</span>
                            )
            )

<span class="fc" id="L232">            val atEnd = isAtEnd(lookAheadIndex + 1)</span>
<span class="fc bfc" id="L233" title="All 4 branches covered.">            if (noMoreCharacters || atEnd) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">                for (i in 0 until lookAheadIndex + 1) {</span>
<span class="fc" id="L235">                    advance()</span>
                }
<span class="fc" id="L237">                return Token(candidate, tokenLine(), tokenPosition(), buffer.toString())</span>
            }
        }
    }

<span class="fc" id="L242">    return null</span>
}

private fun DefaultTokenizer.nextLiteral(): Token? {
<span class="fc bfc" id="L246" title="All 4 branches covered.">    return when (val value = buffer.toString()) {</span>
<span class="fc" id="L247">        &quot;true&quot; -&gt; Token(True, tokenLine(), tokenPosition(), value)</span>
<span class="fc" id="L248">        &quot;false&quot; -&gt; Token(False, tokenLine(), tokenPosition(), value)</span>
<span class="fc" id="L249">        &quot;nil&quot; -&gt; Token(Nil, tokenLine(), tokenPosition(), value)</span>
<span class="fc" id="L250">        else -&gt; null</span>
    }
}

private fun DefaultTokenizer.nextDelimiter(): Token? {
<span class="pc bpc" id="L255" title="2 of 7 branches missed.">    return when (buffer.toString()) {</span>
<span class="fc" id="L256">        &quot;,&quot; -&gt; Token(Comma, tokenLine(), tokenPosition(), tokenValue())</span>
<span class="fc" id="L257">        &quot;;&quot; -&gt; Token(Semicolon, tokenLine(), tokenPosition(), tokenValue())</span>
<span class="fc" id="L258">        else -&gt; null</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>